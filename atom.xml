<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[he is coding]]></title>
  <link href="http://tmac010sjh.github.io/atom.xml" rel="self"/>
  <link href="http://tmac010sjh.github.io/"/>
  <updated>2019-03-01T10:22:34+08:00</updated>
  <id>http://tmac010sjh.github.io/</id>
  <author>
    <name><![CDATA[T_MAC]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Scroller原理分析]]></title>
    <link href="http://tmac010sjh.github.io/blog/2019/03/01/scroller-source-code/"/>
    <updated>2019-03-01T10:10:21+08:00</updated>
    <id>http://tmac010sjh.github.io/blog/2019/03/01/scroller-source-code</id>
    <content type="html"><![CDATA[<h2>代码模版</h2>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="c1">//实例化Scroller对象，在自定义View中，mContext可以在自定义View的构造方法中获取</span>
</span><span class='line'><span class="n">Scroller</span> <span class="n">mScroller</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">Scroller</span><span class="o">(</span><span class="n">mContext</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//在一个自定义View中实现该方法，方法名可以自定义</span>
</span><span class='line'><span class="kd">public</span> <span class="kt">void</span> <span class="nf">smoothScrollTo</span><span class="o">(</span><span class="kt">int</span> <span class="n">destX</span><span class="o">,</span><span class="kt">int</span> <span class="n">destY</span><span class="o">){</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">scrollX</span> <span class="o">=</span> <span class="n">getScrollX</span><span class="o">();</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">scrollY</span>  <span class="o">=</span> <span class="n">getScrollY</span><span class="o">();</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">dx</span> <span class="o">=</span> <span class="n">destX</span> <span class="o">-</span> <span class="n">scrollX</span><span class="o">;</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">dy</span> <span class="o">=</span> <span class="n">destY</span> <span class="o">-</span> <span class="n">scrollY</span><span class="o">;</span>
</span><span class='line'>    <span class="c1">//前两个参数表示起始位置，第三第四个参数表示位移量，最后一个参数表示时间</span>
</span><span class='line'>    <span class="c1">//这一步只是赋值而已</span>
</span><span class='line'>    <span class="n">mScroller</span><span class="o">.</span><span class="na">startScroll</span><span class="o">(</span><span class="n">scrollX</span><span class="o">,</span><span class="n">scrollY</span><span class="o">,</span><span class="n">dx</span><span class="o">,</span><span class="n">dy</span><span class="o">,</span><span class="mi">1000</span><span class="o">);</span>
</span><span class='line'>    <span class="c1">//触发重绘，开始滑动</span>
</span><span class='line'>    <span class="n">invalidate</span><span class="o">();</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//自定义View中重写该方法</span>
</span><span class='line'><span class="nd">@Override</span>
</span><span class='line'><span class="kd">public</span> <span class="kt">void</span> <span class="nf">computeScroll</span><span class="o">(){</span>
</span><span class='line'>    <span class="k">if</span><span class="o">(</span><span class="n">mScroller</span><span class="o">.</span><span class="na">computeScrollOffset</span><span class="o">()){</span>
</span><span class='line'>       <span class="c1">//修改View#mScrollX和mScrollY</span>
</span><span class='line'>       <span class="n">scrollTo</span><span class="o">(</span><span class="n">mScroller</span><span class="o">.</span><span class="na">getCurrX</span><span class="o">(),</span><span class="n">mScroller</span><span class="o">.</span><span class="na">getCurrY</span><span class="o">());</span>
</span><span class='line'>       <span class="c1">//新一轮重绘，不断循环</span>
</span><span class='line'>       <span class="n">postInvalidate</span><span class="o">();</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>




<!-- more -->


<h2>流程图</h2>

<p><img src="http://tmac010sjh.github.io/images/WX20190301-102047@2x.png"></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ViewGroup对触摸事件的处理流程]]></title>
    <link href="http://tmac010sjh.github.io/blog/2019/03/01/viewgroup-number-dispatchtouchevent/"/>
    <updated>2019-03-01T10:09:39+08:00</updated>
    <id>http://tmac010sjh.github.io/blog/2019/03/01/viewgroup-number-dispatchtouchevent</id>
    <content type="html"><![CDATA[<p>伪代码表示，摘自《Android开发艺术探索》</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public boolean dispatchTouchEvent(MotionEvent ev) {
</span><span class='line'>    boolean consume = false;
</span><span class='line'>    if (onInterceptTouchEvent(ev)) {
</span><span class='line'>        consume = onTouchEvent(ev);
</span><span class='line'>    } else {
</span><span class='line'>        consume = child.dispatchTouchEvent(ev);
</span><span class='line'>    }
</span><span class='line'>    return consume;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>




<!-- more -->


<h2>ViewGroup#dispatchTouchEvent处理事件流程</h2>

<h3>第一步先重置</h3>

<p>当ACTION_DOWN来临的时候，重制所有的状态（重制disallow标记位，mFirstTouchTarget置为空），并将ACTION_CACNEL分发给TouchTarget队列里面的View</p>

<h3>第二步判断是否要拦截</h3>

<ul>
<li>如果是down必问一次，是否要拦截，虽然在问之前判断了disallow标记位，但是上面已经说了，只要down就会重置，所以子View无法影响父View对down的处理</li>
<li>如果是其他的比如MOVE、UP，如果当前已经有子View在处理事件了，（mFirstTouchTarget不为空），此时标记位会起作用，如果设置了标记位那么不询问是否要拦截，如果没设置，那每次事件来都问下。。。。另一种情况是mFirstTouchTarget是空，说明之前down的时候已经拦截了，</li>
</ul>


<h3>第三步 如果不拦截，在<code>ACTION_DOWN</code>事件的时候找出合适的子View，将事件传递给他处理</h3>

<h4>问题1:为什么都说如果我（子View）不吃下Down事件，后面的事件我就收不到了呢？</h4>

<ul>
<li>因为父View会在down事件（事件序列中的第一个事件）来临的时候遍历所有的子View，找出第一个愿意处理的，并将他添加到touchTarget队列中，后面有后续的事件来临的时候，会将事件给touchTarget队列中的View处理；所以让自己进touchTarget队列才是最要紧的事啊 :)</li>
</ul>


<h4>问题2:如果没找到咋整</h4>

<ul>
<li>处理down事件的时候，没有合适子View，或者子View都不愿意处理。。。此时mFirstTouchTarget为空，那么这个父View会调用默认实现（super.dispatchTouchEvent）,也就是View#dispatchTouchEvent然后走OnTouchEvent</li>
</ul>


<h4>问题3:如果子View处理了Down，不处理后续的事件（比如Move、up）咋整</h4>

<ul>
<li>不咋整，父View还是会将事件给你，你处理掉最好，处理不掉，父View会找TouchTarget队列中的下一个View来处理（多点触控的情况下），如果都不愿意处理。。。那这个事件就没了。。。父View会一路false返回，最后返回到activity那里</li>
</ul>


<h3>如果拦截了</h3>

<ul>
<li>走默认实现super.dispatchTouchEvent，然后走当前View#OnTouchEvent</li>
<li>如果拦截了Down，那子View啥事件都收不到，除非你手动调用某个View的dispatchEvent(会不会很变态。。。)</li>
<li>如果没拦截Down，拦截了Move，那么之前处理了部分事件的View（比如说之前吃了Down）将收到Cancel事件</li>
</ul>


<h2>关于touchTarget</h2>

<blockquote><p>是个单链表结构，大部分情况下应该只有一个
但如果是多点触控，就不止一个了，第一个手指是<code>ACTION_DOWN</code>，往后就是<code>ACTION_POINTER_DOWN</code>，因此对于<code>ACTION_DOWN</code>和<code>ACTION_POINTER_DOWN</code>走的都是<code>ACTION_DOWN</code>的逻辑</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ScrollView嵌套ViewPager嵌套RecyclerView]]></title>
    <link href="http://tmac010sjh.github.io/blog/2018/11/30/qian-tao/"/>
    <updated>2018-11-30T21:14:24+08:00</updated>
    <id>http://tmac010sjh.github.io/blog/2018/11/30/qian-tao</id>
    <content type="html"><![CDATA[<h3>需求背景</h3>

<blockquote><p>一图胜千言</p></blockquote>

<!-- more -->


<p><img src="http://tmac010sjh.github.io/images/WX20181130-212422@2x.png"></p>

<p>点击<code>展开按钮</code>可以展开</p>

<p><img src="http://tmac010sjh.github.io/images/WX20181130-212443@2x.png"></p>

<ol>
<li>首先这个页面可以竖向滑动</li>
<li>tab栏固定位置，只有tab栏底下的部分滑动</li>
<li>点击上面的tab，底下的条目会有对应的切换，横向滑动下面条目，tab也会更改对应的选中状态</li>
<li>点击展开按钮/收起按钮，条目数量会有对应的变化</li>
<li>tab在切换时，底部的<code>横向RecyclerView</code>不动</li>
</ol>


<h3>实现</h3>

<p>最终我选择的方案是
最外层LinearLayout，里面依次为<code>播放器</code>，<code>TabLayout</code>，<code>ScrollView</code>
ScrollView里面竖向包含ViewPager和底部的横向RecyclerView
ViewPager里面的每个子view都是RecyclerView</p>

<h3>遇到的问题</h3>

<ol>
<li>ViewPager的高度出不来</li>
<li>ScrollView和ViewPager里面的RecyclerView滑动冲突</li>
</ol>


<h3>分析解决</h3>

<h4>ViewPager的高度出不来</h4>

<p>对于这个问题，可以重写ViewPager的<code>onMeasure</code>方法，重新定义测量子View的规则。
还有个问题，每个tab展开收缩的状态都不一样，一次在切tab时，要重新测量</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public class CustomViewPager extends ViewPager {
</span><span class='line'>
</span><span class='line'>    private int current;
</span><span class='line'>    private int height = 0;
</span><span class='line'>    /**
</span><span class='line'>     * 保存position与对于的View
</span><span class='line'>     */
</span><span class='line'>    private SparseArray&lt;View&gt; mChildrenViews = new SparseArray&lt;View&gt;();
</span><span class='line'>
</span><span class='line'>    public CustomViewPager(Context context, AttributeSet attrs) {
</span><span class='line'>        super(context, attrs);
</span><span class='line'>        addOnPageChangeListener(new OnPageChangeListener() {
</span><span class='line'>            @Override
</span><span class='line'>            public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) {
</span><span class='line'>
</span><span class='line'>            }
</span><span class='line'>
</span><span class='line'>            @Override
</span><span class='line'>            public void onPageSelected(int position) {
</span><span class='line'>                resetHeight(position);
</span><span class='line'>            }
</span><span class='line'>
</span><span class='line'>            @Override
</span><span class='line'>            public void onPageScrollStateChanged(int state) {
</span><span class='line'>
</span><span class='line'>            }
</span><span class='line'>        });
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    @Override
</span><span class='line'>    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
</span><span class='line'>
</span><span class='line'>        if (mChildrenViews.size() &gt; current) {
</span><span class='line'>            View child = mChildrenViews.get(current);
</span><span class='line'>            child.measure(widthMeasureSpec, MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED));
</span><span class='line'>            height = child.getMeasuredHeight();
</span><span class='line'>        }
</span><span class='line'>
</span><span class='line'>        heightMeasureSpec = MeasureSpec.makeMeasureSpec(height, MeasureSpec.EXACTLY);
</span><span class='line'>
</span><span class='line'>        super.onMeasure(widthMeasureSpec, heightMeasureSpec);
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    public void resetHeight(int current) {
</span><span class='line'>        this.current = current;
</span><span class='line'>        if (mChildrenViews.size() &gt; current) {
</span><span class='line'>
</span><span class='line'>            FrameLayout.LayoutParams layoutParams = (FrameLayout.LayoutParams) getLayoutParams();
</span><span class='line'>            if (layoutParams == null) {
</span><span class='line'>                layoutParams = new FrameLayout.LayoutParams(LinearLayout.LayoutParams.MATCH_PARENT, height);
</span><span class='line'>            } else {
</span><span class='line'>                layoutParams.height = height;
</span><span class='line'>            }
</span><span class='line'>            setLayoutParams(layoutParams);
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    /**
</span><span class='line'>     * 在RecyclerView初始化之后调用这个方法
</span><span class='line'>     * 
</span><span class='line'>     * 保存position和View的对应关系
</span><span class='line'>     */
</span><span class='line'>    public void setObjectForPosition(View view, int position) {
</span><span class='line'>        mChildrenViews.put(position, view);
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h4>ScrollView和ViewPager里面的RecyclerView滑动冲突</h4>

<p>让ScrollView拦截所有的竖向滑动事件</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public class CustomScrollView extends ScrollView {
</span><span class='line'>
</span><span class='line'>    private int downY;
</span><span class='line'>    private int mTouchSlop;
</span><span class='line'>
</span><span class='line'>    public CustomScrollView(Context context, AttributeSet attrs) {
</span><span class='line'>        super(context, attrs);
</span><span class='line'>        mTouchSlop = ViewConfiguration.get(context).getScaledTouchSlop();
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    @Override
</span><span class='line'>    public boolean onInterceptTouchEvent(MotionEvent ev) {
</span><span class='line'>        int action = ev.getAction();
</span><span class='line'>        switch (action) {
</span><span class='line'>            case MotionEvent.ACTION_DOWN:
</span><span class='line'>                downY = (int) ev.getRawY();
</span><span class='line'>                break;
</span><span class='line'>            case MotionEvent.ACTION_MOVE:
</span><span class='line'>                int moveY = (int) ev.getRawY();
</span><span class='line'>                // 判断是否滑动，若滑动就拦截事件
</span><span class='line'>                if (Math.abs(moveY - downY) &gt; mTouchSlop) {
</span><span class='line'>                    return true;
</span><span class='line'>                }
</span><span class='line'>                break;
</span><span class='line'>            default:
</span><span class='line'>                break;
</span><span class='line'>        }
</span><span class='line'>        return super.onInterceptTouchEvent(ev);
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift语法速查]]></title>
    <link href="http://tmac010sjh.github.io/blog/2018/11/23/get-started-to-swift/"/>
    <updated>2018-11-23T22:13:17+08:00</updated>
    <id>http://tmac010sjh.github.io/blog/2018/11/23/get-started-to-swift</id>
    <content type="html"><![CDATA[<blockquote><p>基于swift3.0
如果有Java或者kotlin基础，可以更快的上手</p></blockquote>

<h3>变量声明</h3>

<p>常量 let
变量 var</p>

<!-- more -->


<h3>元组</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">let</span> <span class="n">people</span> <span class="o">=</span> <span class="p">(</span><span class="s">&quot;John&quot;</span><span class="p">,</span><span class="mi">22</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<h3>数组</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">let</span> <span class="n">stringArray</span> <span class="o">=</span> <span class="n">Array</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span><span class="p">()</span>
</span><span class='line'><span class="k">let</span> <span class="n">floatArray</span> <span class="o">=</span> <span class="p">[</span><span class="n">Float</span><span class="p">]()</span>
</span><span class='line'><span class="k">let</span> <span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="s">&quot;Zoe&quot;</span><span class="p">,</span><span class="s">&quot;Tom&quot;</span><span class="p">]</span>
</span></code></pre></td></tr></table></div></figure>


<h3>字典</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">var</span> <span class="n">dict1</span> <span class="o">=</span> <span class="n">Dictionary</span><span class="o">&lt;</span><span class="n">String</span><span class="p">,</span><span class="n">String</span><span class="o">&gt;</span><span class="p">()</span>
</span><span class='line'>
</span><span class='line'><span class="k">var</span> <span class="n">dict2</span> <span class="o">=</span> <span class="p">[</span><span class="s">&quot;Zoe&quot;</span><span class="o">:</span><span class="mi">78</span><span class="p">,</span><span class="s">&quot;Tom&quot;</span><span class="o">:</span><span class="mi">20</span><span class="p">]</span>
</span></code></pre></td></tr></table></div></figure>


<h3>for</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">for</span> <span class="n">index</span> <span class="k">in</span> <span class="mf">0.</span><span class="p">.</span><span class="o">&lt;</span><span class="mi">3</span>
</span><span class='line'><span class="c1">//区间[0,3)</span>
</span><span class='line'><span class="k">for</span> <span class="n">index</span> <span class="k">in</span> <span class="mf">0.</span><span class="p">.</span><span class="mf">.3</span>
</span><span class='line'><span class="c1">//区间[0,3]</span>
</span></code></pre></td></tr></table></div></figure>


<p>遍历数组</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">let</span> <span class="n">students</span> <span class="o">=</span> <span class="p">[</span><span class="s">&quot;Zoe&quot;</span><span class="p">,</span><span class="s">&quot;Tom&quot;</span><span class="p">]</span>
</span><span class='line'><span class="k">for</span> <span class="n">student</span> <span class="k">in</span> <span class="n">students</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="c1">//...</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>遍历字典</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">let</span> <span class="n">scores</span> <span class="o">=</span> <span class="p">[</span><span class="s">&quot;Zoe&quot;</span><span class="o">:</span><span class="mi">78</span><span class="p">,</span><span class="s">&quot;Tom&quot;</span><span class="o">:</span><span class="mi">20</span><span class="p">]</span>
</span><span class='line'><span class="k">for</span> <span class="p">(</span><span class="n">student</span><span class="p">,</span><span class="n">score</span><span class="p">)</span> <span class="k">in</span> <span class="n">scores</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="c1">//...</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>函数</h3>

<p>格式</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">func</span> <span class="err">函数名</span><span class="p">(</span><span class="err">变量</span><span class="o">:</span><span class="err">类型</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="err">返回值</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="c1">//...</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>参数支持默认值</p>

<p>函数的输入输出参数</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">func</span> <span class="nf">swap</span><span class="p">(</span><span class="nl">number</span><span class="p">:</span> <span class="k">inout</span> <span class="n">Double</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="c1">//...</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">var</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">1</span>
</span><span class='line'><span class="n">swap</span><span class="p">(</span><span class="o">&amp;</span><span class="n">num</span><span class="p">)</span><span class="c1">//加上&amp;符号</span>
</span></code></pre></td></tr></table></div></figure>


<h3>结构体</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">struct</span> <span class="err">名称</span> <span class="p">{</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<blockquote><p>类是引用类型，而结构体和枚举都是值类型。值类型是一种当它被指定为常量或者变量，或者被传递给函数时会被拷贝的类型。这意味着你所创建的任何结构体和枚举实例，作为属性所包含的任意值类型，在代码传递中总是被拷贝的。</p></blockquote>

<p>下标</p>

<blockquote><p>结构体、类和枚举都可以定义下标，它可以作为访问集合、列表或序列成员元素的快捷方式。可以使用下标通过索引值来设置或检索值，而不需要为设置和检索分别使用实例方法。</p></blockquote>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">struct</span> <span class="n">MySubscript</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">var</span> <span class="nl">number</span><span class="p">:</span><span class="n">Int</span>
</span><span class='line'>    <span class="k">subscript</span><span class="p">(</span><span class="nl">n</span><span class="p">:</span><span class="n">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Int</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">number</span> <span class="o">*</span> <span class="n">n</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">let</span> <span class="n">subScript</span> <span class="o">=</span> <span class="n">MySubscript</span><span class="p">(</span><span class="nl">number</span><span class="p">:</span><span class="mi">4</span><span class="p">)</span>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="n">subScript</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span><span class="c1">//output 12</span>
</span></code></pre></td></tr></table></div></figure>


<h3>类</h3>

<h4>init方法</h4>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">class</span> <span class="n">Car</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">var</span> <span class="nl">brand</span> <span class="p">:</span> <span class="n">String</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//类似无参数的构造方法</span>
</span><span class='line'>    <span class="k">init</span><span class="p">(){</span>
</span><span class='line'>        <span class="nb">self</span><span class="p">.</span><span class="n">brand</span> <span class="o">=</span> <span class="s">&quot;BMW&quot;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">init</span><span class="p">(</span><span class="nl">brand</span><span class="p">:</span><span class="n">String</span><span class="p">){</span>
</span><span class='line'>        <span class="nb">self</span><span class="p">.</span><span class="n">brand</span> <span class="o">=</span> <span class="n">brand</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">let</span> <span class="n">car1</span> <span class="o">=</span> <span class="n">Car</span><span class="p">()</span>
</span><span class='line'><span class="n">car1</span><span class="p">.</span><span class="n">brand</span> <span class="o">=</span> <span class="s">&quot;Audi&quot;</span>
</span><span class='line'><span class="k">let</span> <span class="n">car2</span> <span class="o">=</span> <span class="n">Car</span><span class="p">(</span><span class="s">&quot;Benz&quot;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<h4>get、set方法</h4>

<p>参见kotlin</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">var</span> <span class="nl">age</span> <span class="p">:</span> <span class="n">Int</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kr">get</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="mi">23</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="kr">set</span><span class="p">(</span><span class="n">newAge</span><span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="n">age</span> <span class="o">=</span> <span class="n">newAge</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h4>willSet和didSet方法</h4>

<p>设置前和设置后的回调</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">var</span> <span class="nl">level</span> <span class="p">:</span> <span class="n">Int</span> <span class="o">=</span> <span class="mi">1</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kr">willSet</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="c1">//设置前</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="kr">didSet</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="c1">//设置后</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h4>静态方法</h4>

<p>使用class关键字</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">class</span> <span class="n">MathTool</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">class</span> <span class="k">func</span> <span class="n">sum</span><span class="p">(</span><span class="nl">a</span><span class="p">:</span><span class="n">Int</span><span class="p">,</span> <span class="nl">b</span><span class="p">:</span><span class="n">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Int</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h4>析构</h4>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">deinit</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>其它</h3>

<h4>字符串输入</h4>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">let</span> <span class="n">age</span>  <span class="o">=</span> <span class="mi">23</span>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="s">&quot;我的年龄是\(age)&quot;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Kotlin踩坑(持续更新ing)]]></title>
    <link href="http://tmac010sjh.github.io/blog/2018/06/05/watch-out-in-kotlin/"/>
    <updated>2018-06-05T18:25:00+08:00</updated>
    <id>http://tmac010sjh.github.io/blog/2018/06/05/watch-out-in-kotlin</id>
    <content type="html"><![CDATA[<blockquote><p>记录kotlin使用过程中的一些小坑，注意点</p></blockquote>

<!-- more -->


<ul>
<li>fragment中使用ktx插件，需要在<code>onViewCreated</code>中使用</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?,
</span><span class='line'>                              savedInstanceState: Bundle?): View? {
</span><span class='line'>        val rootView = inflater.inflate(R.layout.fragment_home, container, false)
</span><span class='line'>        //不可以在这里使用recycler_view，会报npe
</span><span class='line'>        return rootView
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
</span><span class='line'>        super.onViewCreated(view, savedInstanceState)
</span><span class='line'>        val homeButtonAdapter = HomeButtonAdapter()
</span><span class='line'>        recycler_view.adapter = homeButtonAdapter
</span><span class='line'>        recycler_view.layoutManager = GridLayoutManager(context, 3)
</span><span class='line'>
</span><span class='line'>    }</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Kotlin的空安全]]></title>
    <link href="http://tmac010sjh.github.io/blog/2018/06/05/nullsafe-in-kotlin/"/>
    <updated>2018-06-05T18:20:37+08:00</updated>
    <id>http://tmac010sjh.github.io/blog/2018/06/05/nullsafe-in-kotlin</id>
    <content type="html"><![CDATA[<blockquote><p>在声明变量时，我们必须要明确该变量是否为空，如果可以为空，则需要加上<code>？</code>后缀</p></blockquote>

<!-- more -->




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var b : String = null //编译不通过
</span><span class='line'>
</span><span class='line'>var b : String ? = null //通过
</span></code></pre></td></tr></table></div></figure>


<h3>安全的调用</h3>

<p><code>var b : String? = null</code></p>

<blockquote><p>此时当我们需要调用b的方法或者获取他的属性时，我们要确保b不能为null，安全调用操作符<code>?.</code>,当表达式非null时，返回真实的值，否则返回null</p></blockquote>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>print(b?.length) // null
</span><span class='line'>b = "null"
</span><span class='line'>print(b?.length) // 4
</span><span class='line'>
</span><span class='line'>等价于
</span><span class='line'>
</span><span class='line'>if(b==null){
</span><span class='line'>    print(null)
</span><span class='line'>}else{
</span><span class='line'>    print(b.length)
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<blockquote><p>也可以处理成，发现null直接抛出NullPointException，而不是继续返回null，使用操作符<code>!!</code></p></blockquote>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var b : String? = null
</span><span class='line'>print(b!!.length) // 抛出异常
</span><span class='line'>
</span><span class='line'>等价于
</span><span class='line'>
</span><span class='line'>if(b==null){
</span><span class='line'>    throw NullPointerException()
</span><span class='line'>}else{
</span><span class='line'>    print(b.length)
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<h3>Elvis操作符</h3>

<blockquote><ul>
<li>使用符号<code>?:</code></li>
<li>如果 ?: 左侧表达式非空，返回其左侧表达式，否则返回右侧表达式。 请注意，当且仅当左侧为空时，才会对右侧表达式求值。</li>
</ul>
</blockquote>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>val l = b?.length ?: -1
</span><span class='line'>
</span><span class='line'>等价于
</span><span class='line'>
</span><span class='line'>if(b == null){
</span><span class='line'>    l = -1
</span><span class='line'>}else{
</span><span class='line'>    l = b.length
</span><span class='line'>}
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure>


<blockquote><ul>
<li>右侧表达式还支持<code>抛异常</code>和<code>return</code></li>
</ul>
</blockquote>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>fun doSth(){
</span><span class='line'>    ...
</span><span class='line'>    val l = b?.length ?: return
</span><span class='line'>    val l = b?.length ?: throw NullPointException()
</span><span class='line'>    ...
</span><span class='line'>}
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Kotlin中的类]]></title>
    <link href="http://tmac010sjh.github.io/blog/2018/06/05/classes-in-kotlin/"/>
    <updated>2018-06-05T18:16:21+08:00</updated>
    <id>http://tmac010sjh.github.io/blog/2018/06/05/classes-in-kotlin</id>
    <content type="html"><![CDATA[<h3>继承</h3>

<ul>
<li>继承和实现接口都使用<code>:</code></li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class A : B()</span></code></pre></td></tr></table></div></figure>




<!-- more -->


<h3>超类</h3>

<blockquote><ul>
<li>kotlin中万物的超类是<code>Any</code>&hellip;对应Java中的<code>Object</code></li>
<li>默认声明的类都是final的，如果要声明一个可以继承的类，需添加关键字<code>open</code></li>
<li>方法也是一样的，如果支持<code>override</code>，也需要加<code>open</code></li>
<li>属性也是支持覆盖的，加<code>open</code>,本质上就是重写该属性的get方法</li>
</ul>
</blockquote>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>open class Shape{
</span><span class='line'>    open val name : String = "Shape"
</span><span class='line'>
</span><span class='line'>    open fun doSth(){
</span><span class='line'>        //...
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>class Rectangle : Shape(){
</span><span class='line'>    
</span><span class='line'>    override val name: String
</span><span class='line'>        get() = "2222"
</span><span class='line'>
</span><span class='line'>    override fun dosth() {
</span><span class='line'>        super.dosth()
</span><span class='line'>    }
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<blockquote><p>如果本身是抽象类，那就不需要<code>open</code>了</p></blockquote>

<h3>接口</h3>

<ul>
<li>和Java8一样，支持默认实现</li>
<li>可以声明属性，但是必须是抽象的或者使用访问器实现</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>interface x {
</span><span class='line'>    val count : Int = 1 //编译不通过
</span><span class='line'>    
</span><span class='line'>    val count : Int // pass
</span><span class='line'>    //等价于 
</span><span class='line'>    fun getCount() : Int
</span><span class='line'>    
</span><span class='line'>    val count : Int 
</span><span class='line'>        get()= 666
</span><span class='line'>    //等价于在上面的基础上提供了默认值666    
</span><span class='line'>
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<ul>
<li><code>override</code>冲突</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>interface A{
</span><span class='line'>    fun doSth()
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>interface B{
</span><span class='line'>    fun doSth()
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>class C : A,B{
</span><span class='line'>    override fun doSth(){
</span><span class='line'>        super&lt;A&gt;.doSth() // 指明调用A的方法
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure>


<h3>嵌套类</h3>

<blockquote><p>两种，一种有<code>inner</code>关键字，相当于Java的非静态内部类，可以访问外部类对象，一种没有，相当于Java的静态内部类</p></blockquote>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class A{
</span><span class='line'>    val name = "name"
</span><span class='line'>
</span><span class='line'>    inner class B {
</span><span class='line'>        fun x() = name
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    class C {
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>匿名类</h3>

<blockquote><p>使用<code>object</code>关键字</p></blockquote>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>window.addMouseListener(object : MouseAdapter() {
</span><span class='line'>    override fun mouseClicked(e: MouseEvent) {
</span><span class='line'>        //...
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    override fun mouseEntered(e: MouseEvent) {
</span><span class='line'>        //...
</span><span class='line'>    }
</span><span class='line'>})</span></code></pre></td></tr></table></div></figure>


<blockquote><p>生成某个超类的子类对象，并且这个子类对象还实现了某某接口</p></blockquote>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>open class A(x: Int) {
</span><span class='line'>    public open val y: Int = x
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>interface B {...}
</span><span class='line'>
</span><span class='line'>val ab: A = object : A(1), B {
</span><span class='line'>    override val y = 15
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>println(ab is A) //true
</span><span class='line'>println(ab is B) //true 
</span><span class='line'>
</span><span class='line'>//is 等于 Java的 instanceof</span></code></pre></td></tr></table></div></figure>


<blockquote><p>或者仅仅是一个匿名对象</p></blockquote>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>val nothing = object {
</span><span class='line'>        var x: Int = 0
</span><span class='line'>        var y: Int = 0
</span><span class='line'>        
</span><span class='line'>        fun work(){
</span><span class='line'>            //...
</span><span class='line'>        }   
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>println(nothing.x)    
</span></code></pre></td></tr></table></div></figure>


<h3>单例类</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>object Single {
</span><span class='line'>    
</span><span class='line'>    fun work(){
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>Single.work()//可以直接调用</span></code></pre></td></tr></table></div></figure>


<blockquote><p>类似于Java中的饿汉式单例模式</p></blockquote>

<h3>伴生类</h3>

<blockquote><ul>
<li>使用关键字<code>companion</code></li>
<li>必须定义在类中</li>
<li>效果等同于Java中的静态变量，静态方法</li>
</ul>
</blockquote>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class A {
</span><span class='line'>
</span><span class='line'>    companion object {
</span><span class='line'>        val NUM = 100
</span><span class='line'>        
</span><span class='line'>        fun work() {
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>//可以直接当成静态变量访问
</span><span class='line'>print(A.NUM)
</span><span class='line'>A.work()
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Kotlin入门]]></title>
    <link href="http://tmac010sjh.github.io/blog/2018/06/05/get-started-to-kotlin/"/>
    <updated>2018-06-05T18:09:27+08:00</updated>
    <id>http://tmac010sjh.github.io/blog/2018/06/05/get-started-to-kotlin</id>
    <content type="html"><![CDATA[<h3>定义变量</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>val name : String = "this is my name"
</span><span class='line'>var count : Int = 666</span></code></pre></td></tr></table></div></figure>




<!-- more -->


<ul>
<li>关键字<code>var</code>表示声明的变量可变，对应的<code>val</code>表示不可变，作用相当于Java的<code>final</code></li>
<li>kotlin自带空安全检测，因此声明属性时我们必须明确该属性是否可以为<code>null</code>,区别就在与声明时是否加上<code>?</code></li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var name : String = null //编译不通过
</span><span class='line'>
</span><span class='line'>var name : String ? = null //通过
</span></code></pre></td></tr></table></div></figure>


<h3>定义方法</h3>

<blockquote><p>kotlin中可以直接声名方法，和c类似，并不强制方法在类里面</p></blockquote>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>fun 方法名(形参声明:形参类型) : 返回值{
</span><span class='line'>    //...
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<ul>
<li>使用关键字<code>fun</code>开头</li>
<li>参数声名顺序和Java是反的，中间用<code>:</code>隔开</li>
<li>返回值在末尾，用<code>:</code>隔开</li>
</ul>


<blockquote><p>如果返回值为<code>Unit</code>可以省略，等价于Java中的<code>void</code> <br/>
如果方法不在类里面，查看Java字节码，类似于工具类，所有的方法都是静态方法</p></blockquote>

<p>e.g. 文件名: <code>ToastUtil.kt</code></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>fun show(msg : String){
</span><span class='line'>    //...
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p>等价于</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public final class ToastUtil{
</span><span class='line'>    public static void show(String msg){
</span><span class='line'>        //...
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>定义类</h3>

<h4>构造函数</h4>

<blockquote><ul>
<li>类名后面的为主构造函数</li>
<li>可以没有主构造函数</li>
<li>支持多个次构造函数</li>
<li>次构造函数均需要调用主构造函数</li>
<li>次构造函数的参数不能加<code>var</code> 或者<code>val</code></li>
</ul>
</blockquote>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class User(val name : String/*主构造函数*/){
</span><span class='line'>    
</span><span class='line'>    //次构造函数，关键字`constructor`
</span><span class='line'>    constructor(age : Int,name : String) : this(name){
</span><span class='line'>        // : this 调用主构造函数
</span><span class='line'>    
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<blockquote><p>不像次构造函数，主构造函数没有代码块可以执行，kotlin提供了init代码块</p></blockquote>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>init {
</span><span class='line'>    //这里的代码运行在主构造函数中
</span><span class='line'>    //也就是说即使没有主构造函数，这里的代码也会在次构造函数代码块之前执行
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<h4>类属性</h4>

<p>e.g.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class User(val name:String){
</span><span class='line'>    var age : Int = 12
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<ul>
<li><p>kotlin中类的属性默认是私有的，提供<code>get set</code>方法进行访问,(对<code>val</code>声明的不提供<code>set</code>方法)</p></li>
<li><p>属性声明时(或者声明成员变量时)一定要初始化)，如果不能在声明时就初始化可以使用<code>lateinit</code>关键字，等待外部调用<code>set</code>方法进行初始化</p></li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>lateinit var name : String</span></code></pre></td></tr></table></div></figure>


<blockquote><p>注意：<code>lateinit</code>不能修饰基本类型</p></blockquote>

<ul>
<li>属性、init代码块、次构造函数代码块三者的调用顺序</li>
</ul>


<blockquote><p>属性和init代码块按照他们声明的顺序，次构造函数代码块在最后</p></blockquote>

<h4>创建对象</h4>

<blockquote><p>没有<code>new</code>关键字，和python类似</p></blockquote>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>val user = User("Tom")
</span><span class='line'>user.age = 666</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RxJava之concatArray操作符]]></title>
    <link href="http://tmac010sjh.github.io/blog/2017/05/22/rxjava-operator-concatarray/"/>
    <updated>2017-05-22T09:24:09+08:00</updated>
    <id>http://tmac010sjh.github.io/blog/2017/05/22/rxjava-operator-concatarray</id>
    <content type="html"><![CDATA[<blockquote><p>concatArray的作用是连接多个「被订阅者」对象，并让他们挨个儿发射数据</p></blockquote>

<!-- more -->


<p>e.g.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Flowable&lt;Integer&gt; just1 = Flowable.create(e -&gt; {
</span><span class='line'>            
</span><span class='line'>            for (int i = 0; i &lt; 5; i++) {
</span><span class='line'>                e.onNext(i);
</span><span class='line'>            }
</span><span class='line'>            e.onComplete();
</span><span class='line'>            
</span><span class='line'>        }, BackpressureStrategy.LATEST);
</span><span class='line'>
</span><span class='line'>Flowable&lt;Integer&gt; just2 = Flowable.create(e -&gt; {
</span><span class='line'>
</span><span class='line'>            for (int i = 10; i &lt; 15; i++) {
</span><span class='line'>                e.onNext(i);
</span><span class='line'>            }
</span><span class='line'>            e.onComplete();
</span><span class='line'>
</span><span class='line'>        }, BackpressureStrategy.LATEST);
</span><span class='line'>
</span><span class='line'>Flowable.concatArray(just1, just2)
</span><span class='line'>         .subscribe(integer -&gt; 
</span><span class='line'>            log("onNext = " + integer)
</span><span class='line'>         );
</span></code></pre></td></tr></table></div></figure>


<p>log打印如下</p>

<pre><code>onNext = 0
onNext = 1
onNext = 2
onNext = 3
onNext = 4
onNext = 10
onNext = 11
onNext = 12
onNext = 13
onNext = 14
</code></pre>

<p>说明在等待just1发射完数据后，just2才开始发射数据，它们是有序的</p>

<h3>使用场景</h3>

<ul>
<li>通常在项目中，进入一个页面时，为了页面的尽快展示，会先取本地缓存更新ui，然后拉接口</li>
</ul>


<p>这段逻辑可以用RxJava这样表达</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Flowable.concatArray(本地缓存, 接口)
</span><span class='line'>         .subscribe(data -&gt; 
</span><span class='line'>            //更新ui
</span><span class='line'>         );</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rxjava之doOnNext操作符]]></title>
    <link href="http://tmac010sjh.github.io/blog/2017/05/22/rxjava-operator-doonnext/"/>
    <updated>2017-05-22T09:23:44+08:00</updated>
    <id>http://tmac010sjh.github.io/blog/2017/05/22/rxjava-operator-doonnext</id>
    <content type="html"><![CDATA[<blockquote><p> doOnNext 作用是 在「被订阅者」发射出一个事件/数据后，在下游第一时间获取发出的事件/数据</p></blockquote>

<!-- more -->


<p>e.g.</p>

<pre><code>Flowable&lt;Integer&gt; intFlowable = Flowable.create((FlowableOnSubscribe&lt;Integer&gt;) e -&gt; {
            e.onNext(666);//发射一个“666”
            e.onComplete();
        }, BackpressureStrategy.LATEST)

intFlowable
            .doOnNext(integer -&gt; 
            {
                //上面的“e.onNext(666);”执行后，立刻回调这个方法
                log("on next value = " + integer);
            })
            .doAfterNext(integer -&gt; 

                log("after next value = " + integer)
            )
            .subscribe(integer -&gt; {
                log("subscriber value = " + integer);
            });
</code></pre>

<p>这里最后打出来的log顺序是</p>

<pre><code>on next value = 666
subscriber value = 666
after next value = 666
</code></pre>

<p>说明在最下游的订阅者接收到这个666之前，doOnNext已经先收到了</p>

<p>上面还有一个doAfterNext操作符，在订阅者接收到这个666之后，他才收到这个值。。。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RxJava之compose操作符]]></title>
    <link href="http://tmac010sjh.github.io/blog/2017/05/10/rxjava-operator-compose/"/>
    <updated>2017-05-10T14:46:29+08:00</updated>
    <id>http://tmac010sjh.github.io/blog/2017/05/10/rxjava-operator-compose</id>
    <content type="html"><![CDATA[<blockquote><p>这个操作符的作用是对<code>Publisher</code>也就是对 「被观察者/被订阅者」 对象进行操作（区别于之前讲的map是对数据进行操作），然后返回一个新的Flowable对象</p></blockquote>

<!--more-->


<p>这里举一个使用场景就是代码的复用</p>

<p>e.g.Android中经常需要的线程切换</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Flowable.just(666) //假装他是网络请求
</span><span class='line'>        .subscribeOn(Schedulers.io())
</span><span class='line'>        .observeOn(AndroidSchedulers.mainThread())
</span><span class='line'>        .subscribe(new Consumer&lt;Integer&gt;(){
</span><span class='line'>            @overide
</span><span class='line'>            public void accept(@NonNull Integer i) throw Exception{
</span><span class='line'>                //update ui
</span><span class='line'>            }
</span><span class='line'>        });</span></code></pre></td></tr></table></div></figure>


<p>这里的</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>.subscribeOn(Schedulers.io())
</span><span class='line'>.observeOn(AndroidSchedulers.mainThread())</span></code></pre></td></tr></table></div></figure>


<p>把部分的代码可以复用，因此我们放到工具类中</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public class RxUtil {
</span><span class='line'>
</span><span class='line'> public static &lt;T&gt; FlowableTransformer&lt;T, T&gt; scheduler() {
</span><span class='line'>        return new FlowableTransformer&lt;T, T&gt;() {
</span><span class='line'>            @Override
</span><span class='line'>            public Publisher&lt;T&gt; apply(Flowable&lt;T&gt; upstream) {
</span><span class='line'>                return upstream
</span><span class='line'>                        //代码移到这里了
</span><span class='line'>                        .subscribeOn(Schedulers.io())
</span><span class='line'>                        .observeOn(AndroidSchedulers.mainThread());
</span><span class='line'>            }
</span><span class='line'>        };
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>然后用<code>compose</code>操作符带上这坨代码</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Flowable.just(666)
</span><span class='line'>        .compose(RxUtil.&lt;Integer&gt;scheduler())
</span><span class='line'>        .subscribe(new Consumer&lt;Integer&gt;(){
</span><span class='line'>            @overide
</span><span class='line'>            public void accept(@NonNull Integer i) throw Exception{
</span><span class='line'>                //
</span><span class='line'>            }
</span><span class='line'>        });</span></code></pre></td></tr></table></div></figure>


<p><code>compose</code>操作符接收一个<code>FlowableTransformer</code>对象</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public interface FlowableTransformer&lt;Upstream, Downstream&gt; {
</span><span class='line'>    
</span><span class='line'>    @NonNull
</span><span class='line'>    Publisher&lt;Downstream&gt; apply(@NonNull Flowable&lt;Upstream&gt; upstream);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>这里的<code>upstream</code> 代表的是上游的Flowable对象，本例中暂时可以理解成是<code>integerFlowable</code></p>

<p>这里的需要一个返回值<code>Publisher&lt;Downstream&gt;</code>，给下游继续操作，我们返回的是<code>.observeOn执行后的Flowable对象，也就是FlowableObserveOn</code>对象</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RxJava之map操作符]]></title>
    <link href="http://tmac010sjh.github.io/blog/2017/05/09/rxjava-operator-map/"/>
    <updated>2017-05-09T18:55:04+08:00</updated>
    <id>http://tmac010sjh.github.io/blog/2017/05/09/rxjava-operator-map</id>
    <content type="html"><![CDATA[<blockquote><p>map的作用是在 「数据/事件」 传递的过程中添加一层对 「数据/事件」 的处理/转换，然后返回一个新的Flowable对象</p></blockquote>

<!--more-->


<p>e.g. 将传递过来的int类型转成string类型</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Flowable&lt;Integer&gt; intFlowable = Flowable.just(666);
</span><span class='line'>
</span><span class='line'>Flowable&lt;String&gt; stringFlowable = intFlowable.map(new Function&lt;Integer, String&gt;() {
</span><span class='line'>                @Override
</span><span class='line'>                public String apply(@NonNull Integer integer) throws Exception {
</span><span class='line'>                    
</span><span class='line'>                    return “value is = ”+integer;
</span><span class='line'>                }
</span><span class='line'>            });</span></code></pre></td></tr></table></div></figure>


<p>这里的map方法接收一个<code>Function</code>对象</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public interface Function&lt;T, R&gt; {
</span><span class='line'>    R apply(@NonNull T t) throws Exception;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p><code>Function</code>需要两个范型参数，</p>

<p><code>T</code>是入参，如果把整个数据传递的过程想象成是水的流动，那这个<code>T</code>就可以理解成是上游传过来的data类型</p>

<p><code>R</code>是我们定义的返回值类型，也就是传给下游的data类型</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java注解处理器报错：服务配置文件不正确]]></title>
    <link href="http://tmac010sjh.github.io/blog/2017/04/04/issue-java-processor/"/>
    <updated>2017-04-04T16:10:34+08:00</updated>
    <id>http://tmac010sjh.github.io/blog/2017/04/04/issue-java-processor</id>
    <content type="html"><![CDATA[<blockquote><p>最近在研究java注解处理器,遇到了这样一个错误</p></blockquote>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>错误: 服务配置文件不正确, 或构造处理程序对象javax.annotation.processing.Processor: Provider com.google.auto.service.processor.AutoServiceProcessor could not be instantiated: java.lang.NoClassDefFoundError: com/google/common/collect/Multimap时抛出异常错误</span></code></pre></td></tr></table></div></figure>




<!--more-->


<p>按照butterknife的思路，我新建了一个java lib，依赖如下</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>compile 'com.squareup:javapoet:1.8.0’ 用于方便的生成java文件
</span><span class='line'>compile 'com.google.auto.service:auto-service:1.0-rc2’ 用于方便的注册我的处理器
</span><span class='line'>compile 'com.google.auto:auto-common:0.6'</span></code></pre></td></tr></table></div></figure>


<p>由于项目的原因，需要将依赖的类库尽量以jar或者aar的形式加入到项目中，但是发现如果将<code>com.google.auto.service:auto-service:1.0-rc2</code>以jar包的形式引入则会报标题所示的错误</p>

<p>最后分析如下： <br/>
其中auto-service不能以jar包的形式放到lib中，必须是依赖形式引入，考虑原因：auto－service本身也是一个注解生成器，所以需要在编译之前运行，所以gradle在校验的时候，
auto－service已经在运行，为我的processor生成meta－info文件。。。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用RxJava]]></title>
    <link href="http://tmac010sjh.github.io/blog/2017/04/04/use-rxjava-in-android/"/>
    <updated>2017-04-04T15:45:23+08:00</updated>
    <id>http://tmac010sjh.github.io/blog/2017/04/04/use-rxjava-in-android</id>
    <content type="html"><![CDATA[<blockquote><p>RxJava 扩展了观察者模式，以支持对数据和事件的一系列操作</p></blockquote>

<!--more-->


<h3>基本概念</h3>

<h4><strong>被观察者</strong></h4>

<blockquote><p>也就是事件源，Rxjava中用接口<code>Publisher</code>来表示 「被观察者」 这个概念，具体的实现类是Flowable，Flowable里面提供了很多的工厂方法来帮助我们创建各种各样的 「被观察者」</p></blockquote>

<h4><strong>观察者</strong></h4>

<blockquote><p>事件的消费者，Rxjava中用接口<code>Subscriber</code>来表示 「观察者」 这个概念</p></blockquote>

<h4>订阅</h4>

<ul>
<li>先看一下代表 「被观察者/被订阅者」 的<code>Publisher</code>接口</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public interface Publisher&lt;T&gt; {
</span><span class='line'>
</span><span class='line'>/** 
</span><span class='line'>* 请求 「被观察者」 开始传输数据/发出事件
</span><span class='line'>* 
</span><span class='line'>* 参数接收一个「观察者」对象，该 「观察者」 将收到「被观察者」发射的一系列数据/事件
</span><span class='line'>*/
</span><span class='line'>public void subscribe(Subscriber&lt;? super T&gt; s);
</span><span class='line'>
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<ul>
<li>再看一下 代表 「观察者」 的<code>Subscriber</code>接口</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public interface Subscriber&lt;T&gt; {
</span><span class='line'>    
</span><span class='line'>   /**
</span><span class='line'>    * 订阅发生时，此方法被回调,
</span><span class='line'>    * 也就是在Publisher#subscribe(Subscriber&lt;? super T&gt; s)被调用后
</span><span class='line'>    * 这个方法被回调
</span><span class='line'>    */
</span><span class='line'>    public void onSubscribe(Subscription s);
</span><span class='line'>
</span><span class='line'>   /**
</span><span class='line'>    * 接收到 「被观察者」 发出的数据/事件
</span><span class='line'>    */
</span><span class='line'>    public void onNext(T t);
</span><span class='line'>
</span><span class='line'>    /**
</span><span class='line'>    * 整个订阅的流程中抛出的任何异常都会回调到这个方法
</span><span class='line'>    * 
</span><span class='line'>    */
</span><span class='line'>    public void onError(Throwable t);
</span><span class='line'>
</span><span class='line'>    /**
</span><span class='line'>    * 当
</span><span class='line'>    * 「被观察者」 发射数据/事件完成
</span><span class='line'>    * 此方法会被回调
</span><span class='line'>    * 此后 「被观察者」 不会再发出任何数据/事件
</span><span class='line'>    */
</span><span class='line'>    public void onComplete();
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>所以让整个流程开始运作只需要</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>publisher
</span><span class='line'>    .subscribe
</span><span class='line'>    (subscriber);</span></code></pre></td></tr></table></div></figure>


<h3>创建 <strong>被观察者/被订阅者</strong></h3>

<ul>
<li>用Flowable的工厂方法<code>create</code></li>
</ul>


<p>e.g. 创建一个 「被观察者」 ,他在被subscribe后会发射一个数字<code>666</code></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Flowable&lt;Integer&gt; integerFlowable 
</span><span class='line'>= Flowable.create(new FlowableOnSubscribe&lt;Integer&gt;() {
</span><span class='line'>                @Override
</span><span class='line'>                public void subscribe(FlowableEmitter&lt;Integer&gt; e) throws Exception {
</span><span class='line'>                        e.onNext(666);//往下游传递数据
</span><span class='line'>                        e.onComplete();//结束
</span><span class='line'>                }
</span><span class='line'>            }, BackpressureStrategy.LATEST);//背压策略
</span></code></pre></td></tr></table></div></figure>


<p>这里的 <code>FlowableEmitter</code> <strong>暂时</strong> 可以理解成是我们在<code>subscribe(Subscriber&lt;? super T&gt; s)</code>中传入的 「观察者」 对象，看上去好像是 「被观察者」 直接持有了 「观察者」 ，然后调用他的各种方法。。。
(这里的细节后面再写。。。)</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>integerFlowable.subscribe(new Subscriber&lt;Integer&gt;() {
</span><span class='line'>            @Override
</span><span class='line'>            public void onSubscribe(Subscription s) {
</span><span class='line'>                //这里需要手动调用一下该方法，使 被观察者开始工作
</span><span class='line'>                s.request(Long.MAX_VALUE);
</span><span class='line'>            }
</span><span class='line'>
</span><span class='line'>            @Override
</span><span class='line'>            public void onNext(Integer integer) {
</span><span class='line'>                //这里收到 被观察者/被订阅者 发出的666
</span><span class='line'>            }
</span><span class='line'>
</span><span class='line'>            @Override
</span><span class='line'>            public void onError(Throwable t) {
</span><span class='line'>
</span><span class='line'>            }
</span><span class='line'>
</span><span class='line'>            @Override
</span><span class='line'>            public void onComplete() {
</span><span class='line'>
</span><span class='line'>            }
</span><span class='line'>        });</span></code></pre></td></tr></table></div></figure>


<h3>简化</h3>

<ul>
<li>对于发射简单的数据，Flowable提供了很多便捷的静态方法用来创建Flowable对象，
比如像例子中的integerFlowable，可以这样写</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Flowable&lt;Integer&gt; f = Flowable.just(666);</span></code></pre></td></tr></table></div></figure>


<ul>
<li>很多时候我们创建 「观察者/订阅者」 时并不需要重写这么多的方法

<ul>
<li>比如说每次都要调用<code>s.request(Long.MAX_VALUE)</code></li>
<li>有时候我们也并不关注<code>onComplete</code></li>
<li>我们大多数情况下只需要<code>onNext(T t)</code>和<code>onError(Throwable t)</code></li>
</ul>
</li>
</ul>


<p>因此Flowable中有很多subscribe()的方法重载</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public final Disposable subscribe(
</span><span class='line'>    Consumer&lt;? super T&gt; onNext,
</span><span class='line'>    Consumer&lt;? super Throwable&gt; onError,
</span><span class='line'>    Action onComplete,
</span><span class='line'>    Consumer&lt;? super Subscription&gt; onSubscribe)
</span><span class='line'>);</span></code></pre></td></tr></table></div></figure>


<p>这里的四个参数就等价于Subscriber的那四个回调方法，可以只对需要处理的回调传入参数</p>

<p>比如我只处理结果和异常</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>    integerFlowable.subscribe(new Consumer&lt;Integer&gt;() {
</span><span class='line'>        @Override
</span><span class='line'>        public void accept(@NonNull Integer integer) throws Exception {
</span><span class='line'>            //这里收到 被观察者/被订阅者 发出的666
</span><span class='line'>        }
</span><span class='line'>    }, new Consumer&lt;Throwable&gt;() {
</span><span class='line'>        @Override
</span><span class='line'>        public void accept(@NonNull Throwable throwable) throws Exception {
</span><span class='line'>            //异常处理
</span><span class='line'>        }
</span><span class='line'>    });
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure>


<h3>RxJava中的线程切换</h3>

<blockquote><p>RxJava在Android中常见的使用场景就是拿来异步更新UI，比如说 「被观察者/被订阅者」 从本地或者网络取数据，然后传给 「观察者/订阅者」 更新UI，但是这个取数据的过程可能是很耗时的，所以通常会让 「被观察者/被订阅者」 在子线程去处理他的逻辑，等数据ok后，「观察者/订阅者」在ui线程去更新ui</p></blockquote>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Flowable remoteFlowable = Flowable.create(new FlowableOnSubscribe&lt;Integer&gt;() {
</span><span class='line'>                @Override
</span><span class='line'>                public void subscribe(FlowableEmitter&lt;Integer&gt; e) throws Exception {
</span><span class='line'>                        //发起网络请求。。。。
</span><span class='line'>                        e.onNext(数据);//传递数据
</span><span class='line'>                        e.onComplete();//告诉订阅者，这事儿已经完成
</span><span class='line'>                }
</span><span class='line'>            }, BackpressureStrategy.LATEST);
</span><span class='line'>            
</span><span class='line'>            
</span><span class='line'>remoteFlowable.subscribeOn(Schedulers.io())
</span><span class='line'>              .observeOn(AndroidSchedulers.mainThread())
</span><span class='line'>              .subscribe(new Consumer&lt;Integer&gt;() {
</span><span class='line'>                        @Override
</span><span class='line'>                        public void accept(@NonNull Integer integer) throws Exception {
</span><span class='line'>                            //更新UI
</span><span class='line'>                        }
</span><span class='line'>                    });</span></code></pre></td></tr></table></div></figure>


<p><code>subscribeOn(Schedulers.io())</code> 订阅在io线程，也就是说 「被订阅者/被观察者」 将在io线程执行他的那一坨逻辑（网络请求）</p>

<p><code>observeOn(AndroidSchedulers.mainThread())</code>观察在主线程，也就是说
「订阅者/观察者」将在主线程执行他的那一坨逻辑（更新ui）</p>

<blockquote><p><a href="http://tomstechnicalblog.blogspot.hk/2016/02/rxjava-understanding-observeon-and.html">线程如何切换</a></p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Studio的环境配置]]></title>
    <link href="http://tmac010sjh.github.io/blog/2017/04/02/android-studio-config/"/>
    <updated>2017-04-02T16:35:47+08:00</updated>
    <id>http://tmac010sjh.github.io/blog/2017/04/02/android-studio-config</id>
    <content type="html"><![CDATA[<h3>各种<code>gradle</code>文件</h3>

<ul>
<li>位于根目录下的<code>build.gradle</code></li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>buildscript {
</span><span class='line'>    repositories {//依赖仓库
</span><span class='line'>        jcenter()
</span><span class='line'>
</span><span class='line'>    }
</span><span class='line'>    dependencies {
</span><span class='line'>        classpath 'com.android.tools.build:gradle:2.1.3' //grale插件版本
</span><span class='line'>    }
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p> <!--more--></p>

<ul>
<li>各个module目录下的build.gradle文件</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>apply plugin: 'com.android.application' //说明这个module是一个application
</span><span class='line'>apply plugin: 'com.android.library' //说明这个module是一个library
</span><span class='line'>
</span><span class='line'>//声明此module需要哪些依赖
</span><span class='line'>dependencies { 
</span><span class='line'>    compile fileTree(dir: 'libs', include: ['*.jar']) // lib目录下所有的jar包
</span><span class='line'>    compile project(':XXXLib') //依赖当前工程中的XXXLib
</span><span class='line'>    compile(name: 'XXXLib', ext: 'aar') //依赖lib中的XXXLib.aar文件
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<ul>
<li>根目录下的<code>settings.gradle</code></li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//当前工程的模块清单
</span><span class='line'>//include进来的module才会进行编译,因此建议我们只需include我们正在开发的module和必须依赖的module,以减少不必要的编译时间
</span><span class='line'>
</span><span class='line'>include ':app'
</span><span class='line'>//include ':xxxLib'</span></code></pre></td></tr></table></div></figure>


<ul>
<li>根目录下的<code>gradle.propertities</code></li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//构件工具gradle的配置,建议添加如下配置,加快构建速度
</span><span class='line'>org.gradle.jvmargs=-Xmx2048m -XX\:MaxPermSize\=512m -XX\:+HeapDumpOnOutOfMemoryError -Dfile.encoding\=UTF-8
</span><span class='line'>org.gradle.daemon=true // 开启守护进程
</span><span class='line'>org.gradle.parallel=true // 平行编译</span></code></pre></td></tr></table></div></figure>


<h3>加大内存分配</h3>

<p><img src="http://static.zybuluo.com/tmac010sjh/8x1mcn4qov9dzg8e6t05d1wr/image_1ark5t9g519n61t82hpk4u040n9.png" alt="help -&gt; edit custom vm options" />
改成</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>-Xms2048m
</span><span class='line'>-Xmx4096m
</span><span class='line'>-XX:MaxPermSize=1024m
</span><span class='line'>-XX:ReservedCodeCacheSize=1024m
</span><span class='line'>-XX:+UseCompressedOops</span></code></pre></td></tr></table></div></figure>


<p>重启AS，勾选设置中的show memory indicator,右下角会出现
<img src="http://static.zybuluo.com/tmac010sjh/bxm8f6zvczpgoc6bbmns178a/image_1ark5mvcaf2k2l51gbv1obu1kucm.png" alt="标识" />
查看是否生效</p>

<hr />

<h3>设置(optional)</h3>

<ul>
<li>自动导包</li>
</ul>


<p><img src="http://static.zybuluo.com/tmac010sjh/hy8azpmob46mrw36ddro0y3g/image_1ark62nb917mseg1i5s3k51kivm.png" alt="image_1ark62nb917mseg1i5s3k51kivm.png-80.4kB" /></p>

<ul>
<li>代码提示，关闭大小写敏感</li>
</ul>


<p><img src="http://static.zybuluo.com/tmac010sjh/g8wm296b5909n9accaspmll0/image_1ark674sm6i41rmnscqt2e1cpi13.png" alt="image_1ark674sm6i41rmnscqt2e1cpi13.png-113.1kB" /></p>

<ul>
<li>代码生成,按照一般的命名规范,成员变量前添加m,静态添加s</li>
</ul>


<p><img src="http://static.zybuluo.com/tmac010sjh/tox98ay3nv12i94ld452jdus/image_1ark6kfnsuqo9094ud16fvcbh1g.png" alt="image_1ark6kfnsuqo9094ud16fvcbh1g.png-140.9kB" /></p>

<hr />

<h3>常用快捷键</h3>

<ul>
<li>推荐使用Android Studio默认快捷键,比eclipse更强大</li>
<li>格式化代码：cmd＋option＋l</li>
<li>代码完成：

<ul>
<li>enter 或者 tab 注意区别</li>
<li>可同时按shift＋cmd＋enter,将在行尾自动添加分号,对于if,将自动添加大括号</li>
</ul>
</li>
<li>进入下一行：shift＋enter</li>
<li>代码提示：option ＋ enter</li>
<li>查找调用：option ＋ F7</li>
<li>查看文档：F1</li>
<li>提升为成员变量：cmd＋option＋f</li>
<li>提取局部变量：cmd＋option＋v</li>
<li>大小写转换：cmd＋shift＋u</li>
<li>代码生成器：cmd＋n</li>
<li>搜索：

<ul>
<li>搜索类：cmd＋o</li>
<li>搜索文件(范围涵盖搜索类)：cmd＋n</li>
<li>搜索一个action(比如run,clean,rebuild)：cmd＋shift＋a</li>
<li>搜索所有的(涵盖上面所有的)：双击shift</li>
</ul>
</li>
<li>代码模版</li>
</ul>


<hr />

<p><img src="http://static.zybuluo.com/tmac010sjh/221i237ieuwnfvmam95ujgpz/image_1ark9k4mq1dlse8m1181i741sc91t.png" alt="image_1ark9k4mq1dlse8m1181i741sc91t.png-130.8kB" /></p>

<p>如图是一些内置的代码模板,我们可以添加自己的代码模版,很方便
下面是一个栗子</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>当我修改别人的代码时,需要添加一些注释来说明修改的原因
</span><span class='line'>像这样：// add by tmac on 16/9/9 添加非空判断
</span><span class='line'>我希望输入adb然后回车就可以</span></code></pre></td></tr></table></div></figure>


<p><img src="http://static.zybuluo.com/tmac010sjh/wlu0plrk2hzyup3ff6dp69lf/image_1asjsuikpu251mk37eenl11veem.png" alt="image_1asjsj6rg134q143u1c6i13fr6nc9.png-153.6kB" /></p>

<ul>
<li>点击右边的加号,在上图箭头指示的位置输入内容</li>
<li>点击Define</li>
<li><img src="http://static.zybuluo.com/tmac010sjh/48jen5msl8kcaktlpf6yl7j0/image_1asjt1mf6197n1lfc1ppn1p79161713.png" alt="image_1asjt1mf6197n1lfc1ppn1p79161713.png-19.3kB" /></li>
<li>点击Edit variables,选择现有的函数</li>
<li><img src="http://static.zybuluo.com/tmac010sjh/2rw5fot0ti2hbc0o6gityywm/image_1asjtvav9mv1g1u19vaul6hc51g.png" alt="image_1asjtvav9mv1g1u19vaul6hc51g.png-25.1kB" /></li>
</ul>


<h3>推荐一些插件</h3>

<ul>
<li>android butterknife zelezny配合butterknife使用</li>
<li>gsonformat 将json转化成对象</li>
<li>android parcelable code generator 自动生成系列化所需代码</li>
</ul>

]]></content>
  </entry>
  
</feed>
